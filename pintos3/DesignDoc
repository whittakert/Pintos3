       	       	    +---------------------------+
		    |		CIS 520		|
		    | PROJECT 3: VIRTUAL MEMORY	|
		    |	   DESIGN DOCUMENT	|
		    +---------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Taylor Whittaker <whittakert@ksu.edu>
Doug Anjard
Ethan Koch

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

	*** We used the pintos3 code provided for us ***
	--> We will document here and in our code where we implement our own code
	and what is provided for us. 

>>>>>>> ADDED BY TAYLOR AS A REFERENCE :) -- although it's not really helping me out much....... 

	4.2 Suggested Order of Implementation
	We suggest the following initial order of implementation:
	1. Frame table (see section 4.1.5 Managing the Frame Table). 
	Change process.c to use your frame table allocator.
	Do not implement swapping yet. If you run out of frames, fail the allocator or panic the kernel.
	After this step, your kernel should still pass all the project 2 test cases.

	--> I think that our process.c already implments this for us. 


	2. Supplemental page table and page fault handler (see section 4.1.4 Managing the Supplemental
	Page Table). Change process.c to record the necessary information in the supplemental page
	table when loading an executable and setting up its stack. Implement loading of code and data
	segments in the page fault handler. For now, consider only valid accesses.
	After this step, your kernel should pass all of the project 2 functionality test cases, but only some
	of the robustness tests.


	3. From here, you can implement stack growth, mapped files, and page reclamation on process
	exit in parallel.


	The next step is to implement eviction (see section 4.1.5 Managing the Frame Table). Initially you could
	choose the page to evict randomly. At this point, you need to consider how to manage accessed and dirty
	bits and aliasing of user and kernel pages. Synchronization is also a concern: how do you deal with it if
	process A faults on a page whose frame process B is in the process of evicting? Finally, implement a
	eviction strategy such as the clock algorithm. 

			PAGE TABLE MANAGEMENT
			=====================

---- DATA STRUCTURES ----

>> A0: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

	--> With the pintos3 starter code, that we were instructed
	to start with, we were provided with the follow structs...

	1. In page.h
	/* Virtual page. */
	struct page 
	  {
	    /* Immutable members. */
	    void *addr;                 /* User virtual address. */
	    bool read_only;             /* Read-only page? */
	    struct thread *thread;      /* Owning thread. */

	    /* Accessed only in owning process context. */
	    struct hash_elem hash_elem; /* struct thread `pages' hash element. */

	    /* Set only in owning process context with frame->frame_lock held.
	       Cleared only with scan_lock and frame->frame_lock held. */
	    struct frame *frame;        /* Page frame. */

	    /* Swap information, protected by frame->frame_lock. */
	    block_sector_t sector;       /* Starting sector of swap area, or -1. */
	    
	    /* Memory-mapped file information, protected by frame->frame_lock. */
	    bool private;               /* False to write back to file,
		                           true to write back to swap. */
	    struct file *file;          /* File. */
	    off_t file_offset;          /* Offset in file. */
	    off_t file_bytes;           /* Bytes to read/write, 1...PGSIZE. */
	  };

	2. In frame.h
	/* A physical frame. */
	struct frame 
	  {
	    struct lock lock;           /* Prevent simultaneous access. */
	    void *base;                 /* Kernel virtual base address. */
	    struct page *page;          /* Mapped process page, if any. */
	  };



---- ALGORITHMS ----

>> A1: In a few paragraphs, describe your code for locating the frame,
>> if any, that contains the data of a given page.


---- SYNCHRONIZATION ----

>> A2: When two user processes both need a new frame at the same time,
>> how are races avoided?

	--> You can see in process.c, setup_stack() uses a lock to make sure
	that when allocating allocating a frame for a new page.
	frame_alloc_and_lock (page) --> try_frame_alloc_and_lock (page) -->
	where we actually aquire the lock. This was implemented in the pintos3
	starter code. 

		       PAGING TO AND FROM DISK
		       =======================

---- ALGORITHMS ----

>> B1: When a frame is required but none is free, some frame must be
>> evicted.  Describe your code for choosing a frame to evict.


>> B2: Explain your heuristic for deciding whether a page fault for an
>> invalid virtual address should cause the stack to be extended into
>> the page that faulted.

			 MEMORY MAPPED FILES
			 ===================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

	--> With the pintos3 starter code, that we were instructed
	to start with, we were provided with the follow struct...

	1. In syscall.c
	/* Binds a mapping id to a region of memory and a file. */
	struct mapping
	  {
	    struct list_elem elem;      /* List element. */
	    int handle;                 /* Mapping id. */
	    struct file *file;          /* File. */
	    uint8_t *base;              /* Start of memory mapping. */
	    size_t page_cnt;            /* Number of pages mapped. */
	  };

---- ALGORITHMS ----

>> C2: Describe how memory mapped files integrate into your virtual
>> memory subsystem.  Explain how the page fault and eviction
>> processes differ between swap pages and other pages.

>> C3: Explain how you determine whether a new file mapping overlaps
>> any existing segment.

---- RATIONALE ----

>> C4: Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?
